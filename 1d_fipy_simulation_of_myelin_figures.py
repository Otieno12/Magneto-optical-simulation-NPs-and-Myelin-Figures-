# -*- coding: utf-8 -*-
"""1D fipy simulation of myelin figures.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Um8MiE9se1mWm4coQnILLIjQShco_BmX
"""

! pip install torch

! pip install moviepy

! pip install realesrgan

! pip install fipy

# ------------------------------------------------------------
# Radial Diffusion-Limited Myelin Growth (FiPy + Fit)
# Based on: "Diffusion-controlled growth of myelin figures" (sakai's publication)
# Author: Edward Otieno
# ------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
from fipy import CellVariable, Grid1D, TransientTerm, DiffusionTerm
from scipy.optimize import curve_fit

# ------------------ Simulation Parameters ------------------
r_core = 10e-6      # inner radius (m)
R_outer = 20e-6     # initial outer radius (m)
R_max = 50e-6       # limit of outer radius (m)
D_shell = 1e-12     # diffusion coefficient of lipid shell (m²/s)
D_core = 1e-9       # core diffusion coefficient (m²/s)
Nr = 400            # spatial resolution
r = np.linspace(r_core, R_max, Nr)
dx = r[1] - r[0]

C_in, C_out = 0.0, 1.0
dt = 0.5
n_steps = 50
tol = 1e-9

# ------------------ FiPy Setup ------------------
mesh = Grid1D(nx=Nr, dx=dx)
C = CellVariable(name="C", mesh=mesh, value=C_in)

# Diffusion profile (core-shell)
D_array = np.full_like(r, D_shell)
D_array[r <= r_core] = D_core
D = CellVariable(name="D", mesh=mesh, value=D_array)

# Boundary conditions
C.constrain(C_in, mesh.facesLeft)
C.constrain(C_out, mesh.facesRight)

# ------------------ Diffusion Loop ------------------
R_values, t_values = [], []
current_R = R_outer

for step in range(n_steps):
    eq = TransientTerm() == DiffusionTerm(coeff=D)
    eq.solve(var=C, dt=dt)

    # Gradient near the outer boundary
    grad_C = np.gradient(C.value, r)
    J_outer = -D_array[-1] * grad_C[-1]

    # Radial growth rate (diffusion-limited)
    dRdt = J_outer / (2 * np.pi * current_R)
    current_R += dRdt * dt

    R_values.append(current_R)
    t_values.append(step * dt)

    if abs(dRdt) < tol or current_R >= R_max:
        break

R_values = np.array(R_values)
t_values = np.array(t_values)

# ------------------ Fit Experimental Model ------------------
def sqrt_growth(t, R0, k):
    return R0 + k * np.sqrt(t)

params, _ = curve_fit(sqrt_growth, t_values, R_values)
R0_fit, k_fit = params

# Effective diffusion coefficient (approx)
# from R ~ R0 + sqrt(2 D_eff (C_s - C_0)t / rho)
# => D_eff ∝ k^2 / 2
D_eff_fit = 0.5 * (k_fit ** 2)

print(f"Fitted R0 = {R0_fit*1e6:.3f} µm")
print(f"Fitted k = {k_fit:.3e} m/s^0.5")
print(f"Estimated D_eff = {D_eff_fit:.3e} m²/s")

# Convert to cm²/s for comparison
D_eff_cm2s = D_eff_fit * 1e4
print(f"→ D_eff = {D_eff_cm2s:.3e} cm²/s (compare with 10e-6–10e-8 cm²/s from paper)")

# ------------------ Plot Results ------------------
plt.figure(figsize=(6,4))
plt.plot(t_values, R_values*1e6, 'o', label='Simulation')
plt.plot(t_values, sqrt_growth(t_values, *params)*1e6, '-', label='Fit √t model')
plt.xlabel('Time (s)')
plt.ylabel('Outer Radius (µm)')
plt.title('Radial Diffusion-Controlled Growth of Myelin Figure')
plt.legend()
plt.tight_layout()
plt.savefig('myelin_growth_fit.png', dpi=200)
plt.show()

# ------------------------------------------------------------
# Radial Diffusion-Limited Myelin Growth (FiPy + Fit)
# Based on: "Diffusion-controlled growth of myelin figures" (2023)
# Author: Edward Otieno
# ------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
from fipy import CellVariable, Grid1D, TransientTerm, DiffusionTerm
from scipy.optimize import curve_fit

# ------------------ Simulation Parameters ------------------
r_core = 10e-6      # inner radius (m)
R_outer = 20e-6     # initial outer radius (m)
R_max = 60e-6       # limit of outer radius (m)
D_shell = 1e-12     # diffusion coefficient of lipid shell (m²/s)
D_core = 1e-9       # core diffusion coefficient (m²/s)
Nr = 400            # spatial resolution
r = np.linspace(r_core, R_max, Nr)
dx = r[1] - r[0]

C_in, C_out = 0.0, 1.0
dt = 0.5
n_steps =20
tol = 1e-9

# ------------------ FiPy Setup ------------------
mesh = Grid1D(nx=Nr, dx=dx)
C = CellVariable(name="C", mesh=mesh, value=C_in)

# Diffusion profile (core-shell)
D_array = np.full_like(r, D_shell)
D_array[r <= r_core] = D_core
D = CellVariable(name="D", mesh=mesh, value=D_array)

# Boundary conditions
C.constrain(C_in, mesh.facesLeft)
C.constrain(C_out, mesh.facesRight)

# ------------------ Diffusion Loop ------------------
R_values, t_values = [], []
current_R = R_outer

for step in range(n_steps):
    eq = TransientTerm() == DiffusionTerm(coeff=D)
    eq.solve(var=C, dt=dt)

    # Gradient near the outer boundary
    grad_C = np.gradient(C.value, r)
    J_outer = -D_array[-1] * grad_C[-1]

    # Radial growth rate (diffusion-limited)
    dRdt = J_outer / (2 * np.pi * current_R)
    current_R += dRdt * dt

    R_values.append(current_R)
    t_values.append(step * dt)

    if abs(dRdt) < tol or current_R >= R_max:
        break

R_values = np.array(R_values)
t_values = np.array(t_values)

# ------------------ Fit Experimental Model ------------------
def sqrt_growth(t, R0, k):
    return R0 + k * np.sqrt(t)

params, _ = curve_fit(sqrt_growth, t_values, R_values)
R0_fit, k_fit = params

# Effective diffusion coefficient (approx)
# from R ~ R0 + sqrt(2 D_eff (C_s - C_0)t / rho)
# => D_eff ∝ k^2 / 2
D_eff_fit = 0.5 * (k_fit ** 2)


print(f"Estimated D_eff = {D_eff_fit:.3e} m²/s")

# Convert to cm²/s for comparison
D_eff_cm2s = D_eff_fit * 1e4
print(f"→ D_eff = {D_eff_cm2s:.3e} cm²/s (compare with 10e-6–10e-7 cm²/s from paper)")

! pip install scipy

"""
fit_myelin_growth.py

FiPy-based workflow to (A) fit an analytic sqrt(t) growth to experimental R(t),
and (B) run a FiPy multilayer radial diffusion + coupled axial growth simulation,
then (C) optionally optimize D_shell (and alpha) to match experimental R(t).

Requirements:
- Python >= 3.9
- numpy, matplotlib, scipy, fipy
- Input CSV: two columns (time_seconds, radius_micrometers), NO header or with header (handled)
- Example usage:
    python fit_myelin_growth.py /path/to/R_vs_t.csv
Author: Edward Otieno (adapted)
Date: 2025
"""

import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit, minimize

# Try import FiPy; if missing, the script will still run the sqrt fit.
try:
    from fipy import CellVariable, Grid1D, TransientTerm, DiffusionTerm
    FIPY_AVAILABLE = True
except Exception as e:
    print("FiPy not available:", e)
    FIPY_AVAILABLE = False

# ---------------------- Utility functions ----------------------
def load_time_radius_csv(path, time_col=0, r_col=1, skip_header=True):
    """
    Loads CSV containing time and radius (radius in micrometers recommended).
    Returns time (s) and R (meters).
    """
    # Try to read with or without header
    try:
        data = np.genfromtxt(path, delimiter=',', dtype=float)
    except Exception as e:
        raise RuntimeError(f"Failed to load CSV: {e}")
    if data.ndim == 1:
        data = data.reshape(1, -1)
    # If header present and first row contains non-numeric, genfromtxt may fail; user should pass clean CSV.
    t = data[:, time_col].astype(float)
    R_um = data[:, r_col].astype(float)
    R_m = R_um * 1e-6
    return t, R_m

def sqrt_model(t, R0, k):
    """R(t) = R0 + k * sqrt(t)"""
    return R0 + k * np.sqrt(t)

# ---------------------- Analytic sqrt fit ----------------------
def fit_sqrt(t, R, n_skip=0):
    """
    Fit R(t) = R0 + k sqrt(t) using scipy.curve_fit.
    n_skip: number of initial points to skip (transient)
    Returns R0, k, D_eff (m^2/s).
    """
    if n_skip >= len(t)-2:
        raise ValueError("n_skip too large")
    t_fit = t[n_skip:]
    R_fit = R[n_skip:]
    # initial guess
    R0_guess = R_fit[0]
    k_guess = max(1e-9, (R_fit[-1]-R_fit[0]) / np.sqrt(t_fit[-1] + 1e-12))
    p0 = [R0_guess, k_guess]
    bounds = ([-np.inf, 0.0], [np.inf, np.inf])  # enforce k >= 0
    popt, pcov = curve_fit(sqrt_model, t_fit, R_fit, p0=p0, bounds=bounds)
    R0, k = popt
    perr = np.sqrt(np.diag(pcov))
    k_err = perr[1] if perr.size>1 else np.nan
    # simple relation: for model R ≈ R0 + sqrt(2 D_eff t), then k = sqrt(2 D_eff) => D_eff = k^2/2
    D_eff = 0.5 * k**2
    D_eff_err = 0.5 * (2*k*k_err) if not np.isnan(k_err) else np.nan
    return {
        'R0': R0,
        'k': k,
        'k_err': k_err,
        'D_eff': D_eff,
        'D_eff_err': D_eff_err,
        't_fit': t_fit,
        'R_fit': R_fit
    }

# ---------------------- FiPy multilayer radial simulation ----------------------
def run_fipy_multilayer(D_shell=1e-12, D_core=1e-9, r_core=10e-6, N_layers=5,
                        d_layer=2e-6, dt=0.5, n_steps=400, alpha=80.0,
                        R_initial=None, L0=10e-6, Nr_per_layer=50, R_max=None):
    """
    Run a 1D radial FiPy model for multilayer myelin diffusion + growth.
    Returns arrays: t_values (s), R_values (m), L_values (m)
    - D_shell: diffusion coefficient in shell layers (m^2/s)
    - D_core: diffusion in core (m^2/s)
    - r_core: core radius (m)
    - N_layers, d_layer: number and thickness (m) of bilayers
    - dt, n_steps: time stepping
    - alpha: axial coupling factor (dL/dt = alpha * dR/dt)
    - R_initial: initial outer radius (if None uses r_core + small)
    - Nr_per_layer: spatial resolution per layer
    - R_max: stop radius (m)
    NOTE: FiPy must be installed for this function.
    """
    if not FIPY_AVAILABLE:
        raise ImportError("FiPy not available in the environment.")
    # Build radial grid
    if R_max is None:
        R_max = r_core + N_layers * d_layer
    Nr = N_layers * Nr_per_layer
    r = np.linspace(r_core, R_max, Nr)
    dx = r[1] - r[0]
    mesh = Grid1D(nx=Nr, dx=dx)
    C = CellVariable(name='C', mesh=mesh, value=0.0)
    # diffusion profile
    D_array = np.full_like(r, D_shell)
    D_array[r <= r_core] = D_core
    D_var = CellVariable(name='D', mesh=mesh, value=D_array)
    # BCs
    C.constrain(0.0, mesh.facesLeft)
    C.constrain(1.0, mesh.facesRight)
    # initial R and L
    if R_initial is None:
        R = r_core + 1e-8
    else:
        R = R_initial
    L = L0
    t_values = []
    R_values = []
    L_values = []
    for step in range(n_steps):
        eq = TransientTerm() == DiffusionTerm(coeff=D_var)
        eq.solve(var=C, dt=dt)
        # use gradient near outer region - fit over last few points to reduce noise
        grad = np.gradient(C.value, r)
        grad_outer = np.mean(grad[-max(3, Nr//200):])  # mean of last few points
        D_at_outer = D_array[-1]
        # flux per unit area (radial)
        Jr = - D_at_outer * grad_outer
        # total flux (circumferential) for cylinder per unit length = 2π r * Jr
        # radial growth rate dR/dt = J_total / (2π R) = Jr * r / R  (but r approximates R)
        # We'll use the standard dR/dt = Jr / (rho_layer * something). For simplicity, use previous formula:
        dRdt = Jr / (2 * np.pi * max(R,1e-12))  # preserve sign
        # If Jr is positive outward flux into shell, dRdt positive
        dLdt = alpha * dRdt
        R = R + dRdt * dt
        L = L + dLdt * dt
        t_values.append(step * dt)
        R_values.append(R)
        L_values.append(L)
        # Stop if R close to R_max or negative/unphysical
        if R <= 0:
            print("Warning: R became non-positive; stopping.")
            break
        if R >= R_max*0.999:
            break
    return np.array(t_values), np.array(R_values), np.array(L_values)

# ---------------------- Objective for optimization ----------------------
def objective_D(params, t_exp, R_exp, use_alpha=False, alpha_fixed=80.0, sim_kwargs=None):
    """
    Objective function to optimize. params: array-like [log10(D_shell), (log10(alpha) optional)]
    sim_kwargs: dictionary for run_fipy_multilayer additional args.
    """
    logD = params[0]
    D_shell = 10.0**logD
    if use_alpha:
        logalpha = params[1]
        alpha = 10.0**logalpha
    else:
        alpha = alpha_fixed
    # Run FiPy simulation (may be slow)
    t_sim, R_sim, L_sim = run_fipy_multilayer(D_shell=D_shell, alpha=alpha, **(sim_kwargs or {}))
    # Interpolate R_sim onto t_exp times (within range)
    if t_sim.size < 2:
        return 1e12
    R_interp = np.interp(t_exp, t_sim, R_sim, left=np.nan, right=np.nan)
    # Only compare times where simulation produced values
    mask = ~np.isnan(R_interp)
    if not np.any(mask):
        return 1e12
    resid = R_interp[mask] - R_exp[mask]
    return np.sum(resid**2)  # SSE

# ---------------------- Main orchestration ----------------------
def main(csv_path, run_fipy_opt=False, optimize=False):
    # Load experimental data
    t_exp, R_exp = load_time_radius_csv(csv_path)
    print(f"Loaded {len(t_exp)} data points from {csv_path}")
    # Sort by time if needed
    order = np.argsort(t_exp)
    t_exp = t_exp[order]
    R_exp = R_exp[order]
    # Baseline sqrt fit
    sqrt_res = fit_sqrt(t_exp, R_exp, n_skip=3)
    print("=== Analytic sqrt fit ===")
    print(f"R0 = {sqrt_res['R0']*1e6:.3f} µm")
    print(f"k  = {sqrt_res['k']:.3e} m s^-1/2")
    print(f"D_eff (from k) = {sqrt_res['D_eff']:.3e} m^2/s = {sqrt_res['D_eff']*1e4:.3e} cm^2/s")
    # Plot analytic fit vs data
    plt.figure(figsize=(6,4))
    plt.plot(t_exp, R_exp*1e6, 'o', label='data')
    t_plot = np.linspace(0, t_exp.max(), 200)
    plt.plot(t_plot, sqrt_model(t_plot, sqrt_res['R0'], sqrt_res['k'])*1e6, '-', label='sqrt fit')
    plt.xlabel('Time (s)')
    plt.ylabel('Radius (µm)')
    plt.title('Analytic sqrt(t) fit')
    plt.legend()
    plt.tight_layout()
    plt.savefig('sqrt_fit_comparison.png', dpi=200)
    print("Saved sqrt_fit_comparison.png")
    # If FiPy not available, stop here
    if not FIPY_AVAILABLE:
        print("FiPy not installed — stopping after analytic fit.")
        return
    # If user wants to run a single FiPy simulation (non-optimized), run with reasonable defaults:
    sim_kwargs = dict(r_core=10e-6, N_layers=5, d_layer=2e-6, Nr_per_layer=50,
                      R_initial=None, L0=10e-6, R_max=None, dt=0.5, n_steps=800)
    D_shell_guess = 1e-12
    alpha_guess = 80.0
    print("Running FiPy simulation with D_shell=%.3e m^2/s, alpha=%.1f ..." % (D_shell_guess, alpha_guess))
    t_sim, R_sim, L_sim = run_fipy_multilayer(D_shell=D_shell_guess, alpha=alpha_guess, **sim_kwargs)
    # Plot comparison
    plt.figure(figsize=(6,4))
    plt.plot(t_exp, R_exp*1e6, 'o', label='data')
    plt.plot(t_sim, R_sim*1e6, '-', label=f'FiPy D={D_shell_guess:.1e}')
    plt.xlabel('Time (s)')
    plt.ylabel('Radius (µm)')
    plt.legend()
    plt.tight_layout()
    plt.savefig('fipy_vs_data.png', dpi=200)
    print("Saved fipy_vs_data.png")
    # Optionally optimize D_shell (log-space) to fit data. This is expensive.
    if optimize:
        print("Starting optimization of D_shell (log-space). This may take time.")
        # initial param: log10(D_shell)
        x0 = [np.log10(D_shell_guess)]
        bounds = [(-15, -6)]  # reasonable range
        res = minimize(lambda x: objective_D(x, t_exp, R_exp, use_alpha=False, sim_kwargs=sim_kwargs),
                       x0, bounds=bounds, method='L-BFGS-B', options={'maxiter': 30})
        if res.success:
            D_opt = 10**res.x[0]
            print("Optimization success. Best-fit D_shell = %.3e m^2/s" % D_opt)
            # rerun sim with optimized D
            t_sim_opt, R_sim_opt, L_sim_opt = run_fipy_multilayer(D_shell=D_opt, alpha=alpha_guess, **sim_kwargs)
            # plot
            plt.figure(figsize=(6,4))
            plt.plot(t_exp, R_exp*1e6, 'o', label='data')
            plt.plot(t_sim_opt, R_sim_opt*1e6, '-', label=f'FiPy optimized D={D_opt:.1e}')
            plt.xlabel('Time (s)')
            plt.ylabel('Radius (µm)')
            plt.legend()
            plt.tight_layout()
            plt.savefig('fipy_optimized_vs_data.png', dpi=200)
            print("Saved fipy_optimized_vs_data.png")
        else:
            print("Optimization failed:", res.message)
    print("Done.")

# ---------------------- If run as script ----------------------
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python fit_myelin_growth.py path_to_R_vs_t.csv [--optimize]")
        sys.exit(1)
    csv_path = sys.argv[1]
    optimize_flag = '--optimize' in sys.argv
    main(csv_path, run_fipy_opt=True, optimize=optimize_flag)