# -*- coding: utf-8 -*-
"""Untitled22.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16g-YH3Ko25R4Giv_t1idxxdDmZpUcTgS
"""

! pip install scipy

"""
radial_1d_solver.py
1D axisymmetric steady radial diffusion solver + quasi-steady growth.
Requires: numpy, scipy, matplotlib

Run:
    python radial_1d_solver.py
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# ---------------- Parameters ----------------
r_core = 10e-6
R_outer = 20e-6
R_max = 20e-6
D_core = 1e-9
D_shell = 1e-12
C_in = 0.0
C_out = 10.0

Nr = 400
r = np.linspace(r_core, R_max, Nr)
dr = r[1]-r[0]

dt_phys = 0.5
n_steps = 80
growth_step_max = 1e-7
tol_dR = 1e-10

# ---------------- Functions ----------------
def build_D_profile(current_R_outer):
    D = np.full_like(r, D_shell)
    D[r <= r_core] = D_core
    return D

def solve_steady_C(current_R_outer):
    idx_outer = np.searchsorted(r, current_R_outer)
    if idx_outer >= Nr:
        idx_outer = Nr-1
    n = idx_outer + 1
    if n < 3:
        C = np.linspace(C_in, C_out, Nr)
        return C, idx_outer
    R = r[:n]
    D = build_D_profile(current_R_outer)[:n]
    diag = np.zeros(n)
    lower = np.zeros(n-1)
    upper = np.zeros(n-1)
    for i in range(1, n-1):
        rp = 0.5*(R[i]+R[i+1])
        rm = 0.5*(R[i]+R[i-1])
        Ap = rp * D[i+1] / (R[i+1]-R[i])
        Am = rm * D[i-1] / (R[i]-R[i-1])
        diag[i] = Ap + Am
        lower[i-1] = -Am
        upper[i]   = -Ap
    diag[0] = 1.0
    diag[-1] = 1.0
    A = diags([diag, lower, upper], [0, -1, 1], format='csr')
    b = np.zeros(n)
    b[0] = C_in
    b[-1] = C_out
    C_small = spsolve(A, b)
    C = np.full(Nr, C_out)
    C[:n] = C_small
    return C, idx_outer

# ---------------- Growth loop ----------------
times, R_vals, J_vals = [], [], []
for step in range(n_steps):
    C, idx_outer = solve_steady_C(R_outer)
    if idx_outer >= 1:
        ip = max(1, idx_outer-1)
        grad_outer = (C[idx_outer] - C[ip]) / (r[idx_outer] - r[ip])
        D_profile = build_D_profile(R_outer)
        J_outer = -2.0 * np.pi * r[ip] * D_profile[ip] * grad_outer
    else:
        J_outer = 0.0
    dRdt = J_outer / (2.0 * np.pi * R_outer) if R_outer > 0 else 0.0
    dR = dRdt * dt_phys
    if abs(dR) > growth_step_max:
        dR = np.sign(dR) * growth_step_max
    times.append(step*dt_phys)
    R_vals.append(R_outer)
    J_vals.append(J_outer)
    print(f"step {step}: R_outer={R_outer*1e6:.6f} um, J_outer={J_outer:.3e}, dRdt={dRdt*1e6:.4f} um/s")
    if abs(dR) < tol_dR:
        print("Growth stabilized. Stopping.")
        break
    R_outer += dR
    if R_outer >= R_max:
        print("Reached R_max. Stopping.")
        R_outer = R_max
        break

# ---------------- Plot and save ----------------
plt.figure(figsize=(10,4))
plt.subplot(1,2,1)
plt.plot(r*1e6, C, '-')
plt.xlabel('r (µm)'); plt.ylabel('C'); plt.title('Steady concentration (last step)')
plt.axvline(R_vals[-1]*1e6, color='k', linestyle='--', label='R_outer')
plt.legend()
plt.subplot(1,2,2)
plt.plot(np.array(times), np.array(R_vals)*1e6, '-o')
plt.xlabel('time (s)'); plt.ylabel('R_outer (µm)'); plt.title('Radial growth')
plt.tight_layout()
plt.savefig('myelin_growth_1d.png', dpi=200)
np.save('myelin_time_1d.npy', np.array(times))
np.save('myelin_radius_1d.npy', np.array(R_vals))
np.save('myelin_flux_1d.npy', np.array(J_vals))
print("Saved myelin_growth_1d.png and arrays.")

# ---------------- FiPy: two-layer radial diffusion ----------------
from fipy import CellVariable, Grid1D, TransientTerm, DiffusionTerm
import numpy as np
import matplotlib.pyplot as plt

# ---------------- Parameters ----------------
Nr = 400
r_core = 10e-6   # inner core radius
R_outer = 20e-6  # outer shell radius
r = np.linspace(r_core, R_outer, Nr)
dx = r[1] - r[0]

# Diffusion coefficients
D_core = 1e-9    # core
D_shell = 1e-12  # shell

# Boundary concentrations
C_in = 0.0
C_out = 1.0

# Mesh and FiPy variable
mesh = Grid1D(nx=Nr, dx=dx)
C = CellVariable(name="C", mesh=mesh, value=C_in)

# ---------------- D profile (bilayer) ----------------
D_array = np.full_like(r, D_shell)
D_array[r <= r_core] = D_core
D = CellVariable(name="D", mesh=mesh, value=D_array)

# ---------------- Boundary conditions ----------------
C.constrain(C_in, mesh.facesLeft)
C.constrain(C_out, mesh.facesRight)

# ---------------- Time stepping ----------------
dt = 0.5
n_steps = 80

for step in range(n_steps):
    eq = TransientTerm() == DiffusionTerm(coeff=D)
    eq.solve(var=C, dt=dt)

# ---------------- Compute radial flux ----------------
grad_C = np.gradient(C.value, r)       # dC/dr
J_r = -D_array * grad_C                # per unit area

# Total flux at outer boundary (radial, cylindrical)
J_outer = J_r[-1] * 2 * np.pi * r[-1]

# Effective D for the shell region (linear approximation)
D_eff_shell = J_outer * (R_outer - r_core) / (2 * np.pi * r[-1] * (C_out - C_in))*10000

print(f"Outer flux: {J_outer:.3e} mol/s")
print(f"Effective diffusion coefficient (shell): {D_eff_shell:.3e} cm^2/s")
# ---------------- Plot ----------------
plt.figure(figsize=(6,4))
plt.plot(r*1e6, C.value, label='Concentration C(r)')
plt.axvline(r_core*1e6, color='r', linestyle='--', label='Core radius')
plt.axvline(R_outer*1e6, color='k', linestyle='--', label='Outer shell')
plt.xlabel('r (µm)')
plt.ylabel('Concentration')
plt.title('Radial concentration profile (bilayer)')
plt.legend()
plt.tight_layout()
plt.show()